# java-thread
## java thread base info

### java thread Operation Mechanism<br>
### java线程运行机制

&emsp;&emsp;通过加快时钟周期来提升处理速度变得越来越困难。随着芯片的速度越来越快，散热也越来越困难。很久都没有看到CPU的原始速度有重大提升了。但我们仍然看到摩尔定律在起作用，CPU的设计者们继续在向每片硅晶上塞入越来越多的晶体管。但他们不再用这些晶体管加快CPU的速度，而是用于生产多核的芯片，让多个CPU共享一个芯片。<br>

&emsp;&emsp;多核处理器的思想是：如果你有多个程序运行在一台机器上，你可以让每个程序单独占据一个核，从而得到多倍的整体性能。<br>

&emsp;&emsp;这些额外的核对于自动加快程序的速度没有任何贡献。程序运行的时间将与它们在上一代硬件上的运行时间相同，除非你编写程序时刻意利用这些额外的核。如果你的程序有高度的并发性，从而能同时运行在多个核上，把运行程序的核增加一倍就能让程序的速度提高一倍。但你必须以一种不同的方式来写程序，而不再像编写标准的程序那样，你需要让你自己的程序主动利用并发性。<br>

&emsp;&emsp;Java从一开始就打算用于并发系统中，它有着可用于构建可靠并发程序的api，通过这些你就能充分利用芯片设计的新进展。<br>

&emsp;&emsp;Java集合有一套并发安全的api实现，程序员不必自己动手编写，可直接使用它们，但还要保证自己读过这些类的文档，弄清楚它们在多线程环境中是否安全，而且保证自己不会把不安全的类当成安全的来用。<br>

&emsp;&emsp;适合多线程同时运行最多的情景是大量的工作分解成并行的计算，然后把每种计算放到单独的线程中。<br>
另外，还有一种情景也很适用于多线程运行，如类中的某个函数调用需要 (相对) 较长的时间完成。如果我们能调用这些函数，在它完成之前又做其它事，其它事做完之后再回来获得这个函数调用的计算结果，那就太好了。

&emsp;&emsp;在分布式程序设计中，跨网络的调用需要花很长时间，但使用远程过程调用机制便意味着跨网络的调用看起来就像一次本地方法的调用，这又意味着我们需要等待调用结束才能做其它事情。如果我们创建一个新的线程来做RMI调用，就可以让那个线程等待结果，同时另一个线程做其他事情。这种方法即使在某一个时刻只能运行一个线程的单核处理器上也是有用的。在RMI调用挂起的时候，另一个线程可能被调度执行。
